//! # Flow State Management
//!
//! This module provides state management for multi-step flow execution.
//! It tracks conversation history, step results, and context across
//! multiple tool invocations in a single flow.

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

/// Manages the state of a multi-step flow execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FlowState {
    /// Current step number in the flow
    pub current_step: usize,
    /// Total number of steps in the flow
    pub total_steps: usize,
    /// Results from completed steps, keyed by step identifier
    pub step_results: HashMap<String, StepResult>,
    /// General context information accumulated during the flow
    pub context: HashMap<String, String>,
    /// Conversation history with the LLM
    pub conversation_history: Vec<ConversationTurn>,
    /// Error history for debugging and recovery
    pub error_history: Vec<FlowError>,
}

/// Represents the result of executing a single step in the flow
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct StepResult {
    /// Step number
    pub step: usize,
    /// Description of what was accomplished
    pub description: String,
    /// Raw response from the LLM
    pub llm_response: String,
    /// Parsed instructions generated by the LLM
    pub instructions: Vec<SolanaInstruction>,
    /// Execution status
    pub status: StepStatus,
    /// Timestamp when step was completed
    pub completed_at: String,
    /// Any additional metadata
    pub metadata: HashMap<String, String>,
}

/// Represents a single Solana instruction
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SolanaInstruction {
    /// Program ID that will execute the instruction
    pub program_id: String,
    /// Accounts involved in the instruction
    pub accounts: Vec<AccountMeta>,
    /// Instruction data
    pub data: String,
    /// Whether this instruction is expected to succeed
    pub should_succeed: bool,
}

/// Account metadata for Solana instructions
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AccountMeta {
    /// Public key of the account
    pub pubkey: String,
    /// Whether the account is a signer
    pub is_signer: bool,
    /// Whether the account is writable
    pub is_writable: bool,
}

/// Status of a step execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum StepStatus {
    /// Step is pending execution
    Pending,
    /// Step is currently being executed
    InProgress,
    /// Step completed successfully
    Success,
    /// Step failed with an error
    Failed(String),
    /// Step was skipped
    Skipped(String),
}

/// Represents a single conversation turn with the LLM
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ConversationTurn {
    /// Turn number
    pub turn: usize,
    /// Step number this turn belongs to
    pub step: usize,
    /// User prompt sent to LLM
    pub user_prompt: String,
    /// System prompt/context provided
    pub system_prompt: String,
    /// LLM's response
    pub llm_response: String,
    /// Tools called during this turn
    pub tools_called: Vec<String>,
    /// Timestamp
    pub timestamp: String,
}

/// Represents an error that occurred during flow execution
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct FlowError {
    /// Step where error occurred
    pub step: usize,
    /// Turn where error occurred
    pub turn: usize,
    /// Error type
    pub error_type: String,
    /// Error message
    pub message: String,
    /// Whether the error was recovered
    pub recovered: bool,
    /// Timestamp
    pub timestamp: String,
}

impl FlowState {
    /// Create a new empty flow state
    pub fn new(total_steps: usize) -> Self {
        Self {
            current_step: 0,
            total_steps,
            step_results: HashMap::new(),
            context: HashMap::new(),
            conversation_history: Vec::new(),
            error_history: Vec::new(),
        }
    }

    /// Add a result for a completed step
    pub fn add_result(&mut self, step_id: String, result: StepResult) {
        self.step_results.insert(step_id, result);
        self.current_step += 1;
    }

    /// Add context information
    pub fn add_context(&mut self, key: String, value: String) {
        self.context.insert(key, value);
    }

    /// Add a conversation turn
    pub fn add_turn(&mut self, turn: ConversationTurn) {
        self.conversation_history.push(turn);
    }

    /// Add an error to the error history
    pub fn add_error(&mut self, error: FlowError) {
        self.error_history.push(error);
    }

    /// Get result for a specific step
    pub fn get_step_result(&self, step_id: &str) -> Option<&StepResult> {
        self.step_results.get(step_id)
    }

    /// Get all results from steps before the current one
    pub fn get_previous_results(&self) -> Vec<&StepResult> {
        self.step_results
            .values()
            .filter(|result| result.step < self.current_step)
            .collect()
    }

    /// Check if the flow is complete
    pub fn is_complete(&self) -> bool {
        self.current_step >= self.total_steps
    }

    /// Get completion percentage
    pub fn completion_percentage(&self) -> f64 {
        if self.total_steps == 0 {
            0.0
        } else {
            (self.current_step as f64 / self.total_steps as f64) * 100.0
        }
    }

    /// Format context for LLM prompt
    pub fn format_context(&self) -> String {
        let mut context_lines = Vec::new();

        for (key, value) in &self.context {
            context_lines.push(format!("{key}: {value}"));
        }

        context_lines.join("\n")
    }

    /// Format step results for LLM prompt
    pub fn format_step_results(&self) -> String {
        let mut result_lines = Vec::new();

        for (step_id, result) in &self.step_results {
            result_lines.push(format!(
                "Step {}: {} - Status: {:?}",
                step_id, result.description, result.status
            ));
            result_lines.push(format!("  Instructions: {}", result.instructions.len()));

            if !result.metadata.is_empty() {
                result_lines.push(format!("  Metadata: {:?}", result.metadata));
            }
        }

        result_lines.join("\n")
    }

    /// Get a summary of the current state
    pub fn get_summary(&self) -> String {
        format!(
            "Flow Progress: {}/{} steps ({:.1}% complete)\n\
            Errors: {}\n\
            Context Items: {}\n\
            Conversation Turns: {}",
            self.current_step,
            self.total_steps,
            self.completion_percentage(),
            self.error_history.len(),
            self.context.len(),
            self.conversation_history.len()
        )
    }
}

impl Default for FlowState {
    fn default() -> Self {
        Self::new(0)
    }
}
