//! YML to Dynamic Flow Converter
//!
//! This module handles converting YML flow definitions to dynamic flow plans
//! for execution.

use crate::yml_schema::{YmlFlow, YmlStep};
use anyhow::Result;
use reev_types::flow::{DynamicFlowPlan, DynamicStep};
use reev_types::tools::ToolName;

/// Converter for YML flow definitions to dynamic flow plans
pub struct YmlConverter;

impl Default for YmlConverter {
    fn default() -> Self {
        Self::new()
    }
}

impl YmlConverter {
    /// Create a new YML converter
    pub fn new() -> Self {
        Self
    }

    /// Convert YML flow to DynamicFlowPlan
    pub fn yml_to_dynamic_flow_plan(
        flow: &YmlFlow,
        initial_context: &reev_types::flow::WalletContext,
    ) -> Result<DynamicFlowPlan> {
        let mut steps = Vec::new();

        // Convert each YML step to DynamicStep
        for yml_step in &flow.steps {
            let dynamic_step = Self::yml_to_dynamic_step(yml_step, &flow.flow_id)?;
            steps.push(dynamic_step);
        }

        // Create DynamicFlowPlan
        let mut plan = DynamicFlowPlan::new(
            flow.flow_id.clone(),
            flow.user_prompt.clone(),
            initial_context.clone(),
        );

        // Add each step to the plan
        for step in steps {
            plan = plan.with_step(step);
        }

        Ok(plan)
    }

    /// Convert YML step to DynamicStep
    pub fn yml_to_dynamic_step(yml_step: &YmlStep, _flow_id: &str) -> Result<DynamicStep> {
        let step_id = yml_step.step_id.clone();

        // Convert expected tool calls to required tools
        let required_tools = if let Some(tool_calls) = &yml_step.expected_tool_calls {
            tool_calls.iter().map(|tc| tc.tool_name.clone()).collect()
        } else {
            vec![]
        };

        // Create DynamicStep
        let step = DynamicStep::new(step_id, yml_step.prompt.clone(), yml_step.context.clone())
            .with_required_tools(required_tools)
            .with_critical(yml_step.critical.unwrap_or(true))
            .with_estimated_time(yml_step.estimated_time_seconds.unwrap_or(30));

        Ok(step)
    }

    /// Convert DynamicStep to YmlStep
    pub fn dynamic_step_to_yml_step(&self, step: &DynamicStep) -> Result<YmlStep> {
        let yml_step = YmlStep {
            step_id: step.step_id.clone(),
            prompt: step.prompt_template.clone(),
            refined_prompt: step.prompt_template.clone(), // Default to original prompt
            context: step.description.clone(),
            critical: Some(step.critical),
            estimated_time_seconds: Some(step.estimated_time_seconds),
            expected_tool_calls: Some(Vec::new()), // Will be generated by ToolExecutor
            expected_tools: if !step.required_tools.is_empty() {
                // Convert required_tools (Vec<String>) to Vec<ToolName>
                Some(
                    step.required_tools
                        .iter()
                        .filter_map(|tool_str| ToolName::from_str_safe(tool_str.into()))
                        .collect(),
                )
            } else {
                None
            },
        };

        Ok(yml_step)
    }
}
