//! Calculates a score based on how closely an agent's generated instruction(s)
//! match the ground truth defined in a benchmark.

use crate::{
    agent::AgentAction,
    benchmark::{BenchmarkAccountMeta, BenchmarkInstruction, TestCase},
};
use solana_sdk::instruction::{AccountMeta, Instruction};
use std::collections::HashMap;
use tracing::{debug, info, warn};

/// Calculates the instruction quality score.
///
/// This function compares the agent-generated instructions against the ground truth
/// `expected_instructions` from the benchmark. It calculates a score based on a weighted
/// comparison of the program ID, accounts, and instruction data.
///
/// # Arguments
/// * `test_case` - The benchmark containing the ground truth.
/// * `actions` - The actions (containing instructions) generated by the agent.
///
/// # Returns
/// A score between `0.0` and `1.0`.
pub fn calculate_instruction_score(
    test_case: &TestCase,
    actions: &[AgentAction],
    key_map: &HashMap<String, String>,
) -> f64 {
    info!("[SCORE] ==> Now calling the REAL instruction scorer.");
    let expected_instructions = &test_case.ground_truth.expected_instructions;
    let generated_instructions: Vec<&Instruction> =
        actions.iter().map(|action| &action.0).collect();

    if expected_instructions.is_empty() {
        // If there's no ground truth to compare against, the agent can't be wrong.
        return 1.0;
    }

    let total_possible_score = calculate_total_possible_instruction_score(test_case);
    if total_possible_score == 0.0 {
        // Avoid division by zero if all weights are zero.
        return 1.0;
    }

    let mut achieved_score = 0.0;

    // Compare each generated instruction with its corresponding expected instruction.
    // The zip ensures we only compare pairs that exist in both lists. If the agent
    // generates a different number of instructions, it will be penalized by not
    // being able to achieve the total possible score.
    for (expected_ix, generated_ix) in expected_instructions
        .iter()
        .zip(generated_instructions.iter())
    {
        achieved_score += score_single_instruction(expected_ix, generated_ix, key_map);
    }

    if generated_instructions.len() != expected_instructions.len() {
        warn!(
            "Mismatch in instruction count. Expected: {}, Generated: {}. Score will be penalized.",
            expected_instructions.len(),
            generated_instructions.len()
        );
    }

    let final_score = achieved_score / total_possible_score;
    debug!(
        achieved_score,
        total_possible_score, final_score, "Instruction score calculated."
    );
    final_score
}

/// Calculates the total possible score by summing all weights in the ground truth.
fn calculate_total_possible_instruction_score(test_case: &TestCase) -> f64 {
    let mut total = 0.0;
    for ix in &test_case.ground_truth.expected_instructions {
        total += ix.program_id_weight;
        // Only include data_weight in the total if it's meant to be scored.
        if ix.data != "..." {
            total += ix.data_weight;
        }
        for acc in &ix.accounts {
            total += acc.weight;
        }
    }
    total
}

/// Compares a single expected instruction against a single generated instruction.
fn score_single_instruction(
    expected_ix: &BenchmarkInstruction,
    generated_ix: &Instruction,
    key_map: &HashMap<String, String>,
) -> f64 {
    let mut score = 0.0;

    // 1. Compare Program ID
    info!(
        "[SCORING-DEBUG] Comparing Program ID. Expected: '{}', Generated: '{}'",
        expected_ix.program_id,
        generated_ix.program_id.to_string()
    );
    if expected_ix.program_id == generated_ix.program_id.to_string() {
        score += expected_ix.program_id_weight;
        debug!(program_id = %expected_ix.program_id, "Program ID matched.");
    } else {
        debug!(
            expected = %expected_ix.program_id,
            generated = %generated_ix.program_id,
            "Program ID mismatch."
        );
    }

    // 2. Compare Instruction Data
    // The ground truth data can be a placeholder "..." or a base58 string.
    if expected_ix.data != "..." {
        match bs58::decode(&expected_ix.data).into_vec() {
            Ok(expected_data_bytes) => {
                if expected_data_bytes == generated_ix.data {
                    score += expected_ix.data_weight;
                    debug!("Instruction data matched.");
                } else {
                    debug!("Instruction data mismatch.");
                }
            }
            Err(_) => {
                warn!(data = %expected_ix.data, "Failed to decode base58 ground truth data.");
            }
        }
    }

    // 3. Compare Accounts
    for (expected_acc, generated_acc) in expected_ix.accounts.iter().zip(&generated_ix.accounts) {
        if account_matches(expected_acc, generated_acc, key_map) {
            score += expected_acc.weight;
            debug!(pubkey = %expected_acc.pubkey, "Account matched.");
        } else {
            debug!(
                pubkey = %expected_acc.pubkey,
                "Account mismatch. Expected: (signer: {}, writable: {}), Generated: (signer: {}, writable: {})",
                expected_acc.is_signer, expected_acc.is_writable,
                generated_acc.is_signer, generated_acc.is_writable
            );
        }
    }

    if expected_ix.accounts.len() != generated_ix.accounts.len() {
        debug!(
            "Mismatch in account count for instruction. Expected: {}, Generated: {}",
            expected_ix.accounts.len(),
            generated_ix.accounts.len()
        );
    }

    score
}

/// Helper to compare a ground truth account with a generated account.
fn account_matches(
    expected: &BenchmarkAccountMeta,
    generated: &AccountMeta,
    key_map: &HashMap<String, String>,
) -> bool {
    // Resolve the expected pubkey. If it's a placeholder (e.g., "USER_WALLET_PUBKEY"),
    // look it up in the key_map. Otherwise, use it directly.
    let expected_pubkey_str = key_map
        .get(&expected.pubkey)
        .cloned()
        .unwrap_or_else(|| expected.pubkey.clone());

    let pubkey_match = expected_pubkey_str == generated.pubkey.to_string();
    let signer_match = expected.is_signer == generated.is_signer;
    let writable_match = expected.is_writable == generated.is_writable;

    info!(
        "[SCORING-DEBUG] Account '{}' | Pubkey Match: {} (Expected: {}, Generated: {})",
        expected.pubkey, pubkey_match, expected_pubkey_str, generated.pubkey
    );
    info!(
        "[SCORING-DEBUG] Account '{}' | Signer Match: {} (Expected: {}, Generated: {})",
        expected.pubkey, signer_match, expected.is_signer, generated.is_signer
    );
    info!(
        "[SCORING-DEBUG] Account '{}' | Writable Match: {} (Expected: {}, Generated: {})",
        expected.pubkey, writable_match, expected.is_writable, generated.is_writable
    );

    pubkey_match && signer_match && writable_match
}
